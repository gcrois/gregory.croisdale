---
import { getCollection } from "astro:content";
import Layout from "@layouts/DefaultLayout.astro";

// 1. Generate a new path for every collection entry
export async function getStaticPaths() {
	const blogEntries = await getCollection("blog");
	return [
		...blogEntries.map((entry) => ({
			params: { slug: entry.slug },
			props: { entry },
		})),
	];
}
// 2. When it's time to render, you can get the entry directly from the prop
const { entry } = Astro.props;
const allBlogEntries = await getCollection("blog");
const seriesInfo = entry.data.series;
const seriesEntries = seriesInfo
	? allBlogEntries
			.filter((candidate) => {
				const candidateSeries = candidate.data.series;
				if (!candidateSeries || candidateSeries.id !== seriesInfo.id) {
					return false;
				}

				return (
					candidate.slug === entry.slug || !candidate.data.unlisted
				);
			})
			.sort((a, b) => {
				const orderDiff =
					(a.data.series?.order ?? 0) - (b.data.series?.order ?? 0);
				if (orderDiff !== 0) {
					return orderDiff;
				}

				return (
					new Date(a.data.date).getTime() -
					new Date(b.data.date).getTime()
				);
			})
	: [];
const currentSeriesIndex = seriesEntries.findIndex(
	(candidate) => candidate.slug === entry.slug
);
const previousSeriesEntry =
	currentSeriesIndex > 0 ? seriesEntries[currentSeriesIndex - 1] : null;
const nextSeriesEntry =
	currentSeriesIndex >= 0 && currentSeriesIndex < seriesEntries.length - 1
		? seriesEntries[currentSeriesIndex + 1]
		: null;
const { Content } = await entry.render();
import { getImage } from "astro:assets";

// Resolve OG Image
let ogImageUrl = entry.data.image;
if (entry.data.image && entry.data.image !== "/images/me.jpg") {
	const fullImagePath = `/src/assets${entry.data.image}`;

	// Handle SVG manual conversion
	if (fullImagePath.endsWith(".svg")) {
		const fs = await import("node:fs/promises");
		const path = await import("node:path");
		const sharp = (await import("sharp")).default;

		const isProd = import.meta.env.PROD;
		// In production, write to 'dist' (or configured outDir) because 'public' is copied earlier.
		// In development, write to 'public' to be served by Vite.
		const baseDir = isProd ? "dist" : "public";
		const publicDir = path.join(process.cwd(), baseDir);
		const ogDir = path.join(publicDir, "og");

		// Ensure OG directory exists
		await fs.mkdir(ogDir, { recursive: true });

		const inputPath = path.join(process.cwd(), fullImagePath);
		const outputFilename = entry.slug.replace(/\//g, "-") + ".png";
		const outputPath = path.join(ogDir, outputFilename);

		try {
			// Convert SVG to PNG
			await sharp(inputPath)
				.resize(1200, 630, {
					fit: "contain",
					background: { r: 255, g: 255, b: 255, alpha: 1 },
				})
				.png()
				.toFile(outputPath);

			ogImageUrl = `/og/${outputFilename}`;
		} catch (e) {
			console.error(`Failed to generate OG image for ${entry.slug}:`, e);
			// Fallback to original SVG URL if conversion fails (though it might not work for OG)
		}
	} else {
		// Existing logic for non-SVG images
		const images = import.meta.glob<{ default: ImageMetadata }>(
			"/src/assets/images/**/*.{jpeg,jpg,png,gif,svg}"
		);

		if (images[fullImagePath]) {
			const imgModule = await images[fullImagePath]();
			const { width, height } = imgModule.default;

			let options: any = { src: imgModule.default, format: "png" };

			// Upscale if too small (min 256px)
			if (width < 256 || height < 256) {
				const scale = 256 / Math.min(width, height);
				options.width = Math.round(width * scale);
				options.height = Math.round(height * scale);
			}

			const optimizedImg = await getImage(options);
			ogImageUrl = optimizedImg.src;
		}
	}
}
---

<!-- If this has a link set, just redirect to it. Otherwise, render the page normally. -->
<Fragment
	set:html={entry.data.link == ""
		? ""
		: `<meta
        http-equiv="Refresh"
        content="0;
        URL=${entry.data.link}
	      "/>`}
/>

<style lang="scss">
	.series-nav {
		margin-top: 3rem;
		padding: 1rem 1.2rem;
		border-radius: 10px;
		border: 1px solid var(--bg-border);
		background: rgba(255, 255, 255, 0.6);
		backdrop-filter: blur(8px);
	}

	.series-title {
		margin: 0 0 0.75rem 0;
		font-size: 0.95rem;
		font-weight: 600;
		color: var(--text-main);
	}

	.series-links {
		display: flex;
		flex-wrap: wrap;
		justify-content: space-between;
		gap: 0.75rem;
	}

	.series-link {
		font-weight: 600;
	}

	.series-link-disabled {
		color: var(--text-secondary);
	}
</style>

<Layout
	title={entry.data.title}
	pageTitle=`Gregory | ' + ${entry.data.title}`
	description={entry.data.description}
	ogImage={ogImageUrl}
>
	<Content />
	{
		seriesInfo && seriesEntries.length > 1 && (
			<nav
				class="series-nav"
				aria-label={`${seriesInfo.title} navigation`}
			>
				<p class="series-title">
					<Fragment set:html={seriesInfo.title} /> (
					{currentSeriesIndex + 1}/{seriesEntries.length})
				</p>
				<div class="series-links">
					{previousSeriesEntry ? (
						<a
							class="series-link"
							href={`/blog/${previousSeriesEntry.slug}/`}
						>
							←{" "}
							<Fragment
								set:html={previousSeriesEntry.data.title}
							/>
						</a>
					) : (
						<span class="series-link-disabled">
							Start of series
						</span>
					)}
					{nextSeriesEntry ? (
						<a
							class="series-link"
							href={`/blog/${nextSeriesEntry.slug}/`}
						>
							<Fragment set:html={nextSeriesEntry.data.title} /> →
						</a>
					) : (
						<span class="series-link-disabled">End of series</span>
					)}
				</div>
			</nav>
		)
	}
</Layout>

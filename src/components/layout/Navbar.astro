---
interface Props {}


---

<div class="navbar">
    <div class="hold">
        <div class="item">
            <slot/>
        </div>
    </div>
</div>

<style>
.hold {
    position: relative;
    margin-top: -2000px;
    pointer-events: none;
}

.hold::before {
    content: "";
    display: block;
    height: 2000px;
    width: 100%;
}

.item {
    pointer-events: initial;
    position: sticky;
    bottom: 0;
    z-index: 100;
}
</style>

<!-- <script>
    const stickies = Array.from(document.querySelectorAll('[data-sticky]') as unknown as HTMLElement[]);

    // get positions of navbars
    let originalPositions: {element: HTMLElement, top: number}[];

    const old_resize = window.onresize || function() {};
    window.onresize = (e: UIEvent | null) => {
        if (e) old_resize.call(window, e);
        // get original positions of navbars
        originalPositions = stickies.map(sticky => {
            const top = sticky.getBoundingClientRect().top;
            return {
                element: sticky,
                top: sticky.offsetTop,
            }
        }).sort((a, b) => a.top - b.top);
        // sorted from top to bottom
    };
    // wait for DOM to load, then call onresize to get initial positions
    setTimeout(
        ()=>{(window.onresize as any)(null);},
        0
    );

    // add onscroll listener
    const old_scroll = window.onscroll || function() {};
    let lastNSticky = 0;
    window.onscroll = (e: Event) => {
        old_scroll.call(window, e);

        // get scroll position
        const scrollY = window.scrollY;
        
        // if next obj from last sticky should be sticky, find likeminded stickers
        if (originalPositions[lastNSticky].top < scrollY) {
            for (let i = 0; i < originalPositions.length; i++) {
                if (originalPositions[i].top > scrollY) {
                    lastNSticky = i;
                    break;
                } else {
                    stickies[lastNSticky].classList.add('sticky');
                }
            }
        } else {
        // otherwise, find how many stickies need to be cleansed
            for (let i = lastNSticky; i >= 0; i--) {
                if (originalPositions[i].top < scrollY) {
                    lastNSticky = i;
                    break;
                } else {
                    stickies[lastNSticky].classList.remove('sticky');
                }
            }
        }
    };
</script> -->